# Vigenere Encoder and Decoder and Kasiski Examination Program

The Vigenere cipher is a classical cipher that was the standard for encryption until its weaknesses were exposed in the 19th century. Although it is not used anymore, it is a good exercise to write a program to encode, decode, and even highlight its weaknesses.

Vigenere encryption involves a plaintext and a key. If the plaintext is longer than the key, then the key is repeated as necessary. Each letter in the key corresponds to a certain amount of shift in the alphabet. For example, if our plaintext were `ATTACKATDAWN`, and our key was `LEMON`, then the first letter of our plaintext would be shifted by 11 letters since `L` is the 11th letter (starting with `A = 0`). This simply results in `A` become `L`, since `A` is the zeroth letter. This process continues, with `T` shifting by 4 letters, the next `T` shifting by 12 letters, and so on until we get `LXFOPVEFRNHR`

Decryption is simply the reverse process, using the key to shift in the opposite direction, and we get our plaintext back.

For centuries, this was impossible to crack, as one would require knowledge of the key used to encode the data. Unless you were lucky, you wouldn't guess the key. In the 19th century, a cryptographer named Kasiski discovered a method to decode Vigenere Ciphers. He exploited the fact that the key repeats after a set length. Thus, every `n` letters (where `n` is the length of the key), the ciphertext would have the same key applied to it. In large texts, repeating phrases result in strings being repeated in the ciphertext, which can be exploited to reveal the length of the key. The distance between repeating strings, when factored, reveals possible key lengths. Although a single set of repeating strings isn't definitive due to some coincidences, the combination of many strings on a longer text can be used to guess the key length. When the length of the key is known, the ciphertext can be split into N different substitution ciphers, which can each be decoded using frequency analysis.

I have developed functions that encode, decode, and perform the Kasiski Examination. I do not tackle the frequency analysis to completely decode the ciphertext, as this requires guesswork and a dictionary of commonly used words. These programs demonstrate ability to manipulate Strings (including their char-based nature), arrays, vectors, maps and pairs.

ASSUMPTIONS: Do not enter lowercase letters to encode (messes up the conversion), and for the Kasiski Examination do not enter any whitespace.

If you would like to see an example to use for Kasiski Examination, we can use a string from https://pages.mtu.edu/~shene/NSF-4/Tutorial/VIG/Vig-Kasiski.html. The ciphertext `LFWKIMJCLPSISWKHJOGLKMVGURAGKMKMXMAMJCVXWUYLGGIISWALXAEYCXMFKMKBQBDCLAEFLFWKIMJCGUZUGSKECZGBWYMOACFVMQKYFWXTWMLAIDOYQBWFGKSDIULQGVSYHJAVEFWBLAEFLFWKIMJCFHSNNGGNWPWDAVMQFAAXWFZCXBVELKWMLAVGKYEDEMJXHUXDAVYXL`, when fed into Kasiski Examination, reveals that the most frequent distance factors are 3 and 6 (we ignore 1 and 2 since they are too short to be meaningful), and the key is in fact, 6 letters (the key is `SYSTEM`).
